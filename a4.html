<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>P5.js 과제 4 - 분해/합체 애니메이션</title>
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.2/p5.js"></script>
  
  <style>
    /* CSS: 캔버스를 화면 중앙에 배치합니다. */
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      background-color: black; /* P5.js 코드에서 배경을 검정(0)으로 설정했기 때문에 통일 */
    }
    .back-btn {
      /* 메인 페이지로 돌아가는 버튼 스타일 */
      position: fixed;
      top: 20px;
      left: 20px;
      padding: 10px 20px;
      background: #f0f0f0; 
      border: 2px solid #3498db;
      color: #3498db;
      text-decoration: none;
      border-radius: 20px;
      font-weight: bold;
      z-index: 1000;
    }
    .back-btn:hover {
      background: #3498db;
      color: white;
    }
  </style>
</head>
<body>
  <a href="./index.html" class="back-btn">✔ 메인으로 돌아가기</a>
  
  <script>
    // ******************************************************
    // 사용자가 제공한 P5.js 코드 시작
    // ******************************************************
    
    // 애니메이션 변수
    let animationPhase = 0;
    let phaseTimer = 0;
    let explosionProgress = 0;
    let assembleProgress = 0;
    let growthScale = 1;

    // 눈 입자 배열
    let snowflakes = [];

    function setup() {
      createCanvas(640, 480); // 캔버스 크기
      frameRate(30); // 30fps
      
      // 눈송이 30개
      for (let i = 0; i < 30; i++) {
        snowflakes.push({
          x: random(width),
          y: random(-height, 0),
          size: random(4, 8),
          speed: random(1.5, 2.5),
          sway: random(-0.3, 0.3)
        });
      }
    }

    function draw() {
      background(0); // 검정색 배경
      
      phaseTimer++;
      
      if (animationPhase === 0) {
        // 분해 단계 (2.5초)
        explosionProgress = min(phaseTimer / 60, 1);
        if (phaseTimer > 60) {
          animationPhase = 1;
          phaseTimer = 0;
        }
      } else if (animationPhase === 1) {
        // 합쳐짐 단계 (2.5초)
        assembleProgress = min(phaseTimer / 60, 1);
        if (phaseTimer > 60) {
          animationPhase = 2;
          phaseTimer = 0;
        }
      } else if (animationPhase === 2) {
        // 커지기 + 귀 움직임 단계 (3초)
        growthScale = 1 + (phaseTimer / 72) * 0.4;
        growthScale = min(growthScale, 1.4);
      }
      
      // 눈 내리기
      drawSnow();
      
      // 토끼 그리기
      drawRabbit(width / 2, height - 120, 1.3 * growthScale);
    }

    // 눈 내리기 함수
    function drawSnow() {
      fill(255);
      noStroke();
      
      for (let flake of snowflakes) {
        ellipse(flake.x, flake.y, flake.size, flake.size);
        
        flake.y += flake.speed;
        flake.x += flake.sway;
        
        if (flake.y > height) {
          flake.y = random(-50, 0);
          flake.x = random(width);
        }
      }
    }

    // 토끼 인형 함수
    function drawRabbit(x, y, s) {
      push();
      translate(x, y);
      scale(s);

      let bodyColor = getAnimatedColor();
      
      // 귀 움직임 계산
      let earBounce = 0;
      if (animationPhase === 2) {
        earBounce = sin(frameCount * 0.12) * 8; // 움직임 범위 축소
      }
      
      stroke(0);
      strokeWeight(2);
      fill(bodyColor);

      // 왼쪽 팔
      push();
      let leftArmOffset = getPartOffset(-60, -100, 0);
      translate(-20 + leftArmOffset.x, -20 + leftArmOffset.y);
      rotate(radians(26));
      ellipse(0, 0, 20, 50);
      pop();

      // 오른쪽 팔
      push();
      let rightArmOffset = getPartOffset(60, -100, 1);
      translate(20 + rightArmOffset.x, -20 + rightArmOffset.y);
      rotate(radians(-26));
      ellipse(0, 0, -20, -50);
      pop();
      
      // 몸통
      push();
      let bodyOffset = getPartOffset(0, -80, 2);
      translate(bodyOffset.x, bodyOffset.y);
      triangle(-32, 15, 32, 15, 0, -65);
      pop();

      // 왼쪽 다리
      push();
      let leftLegOffset = getPartOffset(-40, -60, 3);
      translate(-25 + leftLegOffset.x, 10 + leftLegOffset.y);
      ellipse(0, 0, 35, 50);
      pop();
      
      // 오른쪽 다리
      push();
      let rightLegOffset = getPartOffset(40, -60, 4);
      translate(25 + rightLegOffset.x, 10 + rightLegOffset.y);
      ellipse(0, 0, 35, 50);
      pop();

      // 왼쪽 귀
      push();
      let leftEarOffset = getPartOffset(-50, -150, 5);
      translate(-29 + leftEarOffset.x, -125 + leftEarOffset.y + earBounce);
      ellipse(0, 0, 25, 60);
      pop();

      // 오른쪽 귀
      push();
      let rightEarOffset = getPartOffset(50, -150, 6);
      translate(33 + rightEarOffset.x, -125 + rightEarOffset.y + earBounce);
      rotate(radians(155));
      ellipse(18, -50, 25, 60);
      pop();
      
      // 머리
      push();
      let headOffset = getPartOffset(0, -120, 7);
      translate(headOffset.x, headOffset.y);
      ellipse(0, -80, 70, 70);
      pop();

      // 얼굴
      fill(0);
      noStroke();
      
      // 왼쪽 눈
      push();
      let leftEyeOffset = getPartOffset(-20, -130, 8);
      translate(leftEyeOffset.x, leftEyeOffset.y);
      ellipse(-15, -85, 10, 10);
      pop();
      
      // 오른쪽 눈
      push();
      let rightEyeOffset = getPartOffset(20, -130, 9);
      translate(rightEyeOffset.x, rightEyeOffset.y);
      ellipse(15, -85, 10, 10);
      pop();
      
      // 코
      push();
      let noseOffset = getPartOffset(0, -125, 10);
      translate(noseOffset.x, noseOffset.y);
      ellipse(0, -73, 10, 8);
      pop();

      pop();
    }

    // 각 부위의 오프셋 계산
    function getPartOffset(targetX, targetY, seed) {
      let offset = { x: 0, y: 0 };
      
      if (animationPhase === 0) {
        let angle = seed * 30 + sin(frameCount * 0.06 + seed) * 8;
        let distance = explosionProgress * 180; 
        offset.x = cos(radians(angle)) * distance + targetX * explosionProgress;
        offset.y = sin(radians(angle)) * distance + targetY * explosionProgress;
        
      } else if (animationPhase === 1) {
        let remainingProgress = 1 - assembleProgress;
        let angle = seed * 30 + sin(frameCount * 0.06 + seed) * 8;
        let distance = remainingProgress * 180;
        offset.x = cos(radians(angle)) * distance + targetX * remainingProgress;
        offset.y = sin(radians(angle)) * distance + targetY * remainingProgress;
      }
      
      return offset;
    }

    // 색상 애니메이션
    function getAnimatedColor() {
      if (animationPhase === 0) {
        return lerpColor(color(0), color(128), explosionProgress);
      } else if (animationPhase === 1) {
        return lerpColor(color(128), color(255), assembleProgress);
      } else {
        return color(255);
      }
    }

    // 's' 키로 8초 GIF 저장
    function keyPressed() {
      if (key === 's' || key === 'S') {
        // saveGif('rabbit_animation', 8); // GIF 저장은 로컬에서만 주로 작동
      }
    }
    // ******************************************************
    // P5.js 코드 끝
    // ******************************************************
  </script>
</body>
</html>
